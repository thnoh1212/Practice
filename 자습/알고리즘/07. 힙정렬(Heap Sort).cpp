/*
 힙 정렬 역시 병합 정렬 및 퀵 정렬 정도로 빠른 알고리즘.
 고급 프로그래밍 기법으로 갈 수록 힙의 개념이 자주 등장하기에
 반드시 알아야 함.
 힙을 알기 전 우선 이진트리에 대해 알 필요가 있음
 트리 : 말 그대로 가지를 뻗어나가는 것 처럼 데이터가 서로 연결
 		되어있는 구조를 의미함 
 이진트리 : 컴퓨터가 데이터를 표현할 때 데이터를 각 노드(Node)에
 		    담은 후 노드를 두 개씩 이어붙이는 구조.
			이진트리는 모든 노드의 자식 노드가 2개 이하인 트리
 완전이진트리 : 데이터가 루트(Root)노드부터 시작해서 자식 노드가
 				왼쪽 자식 노드, 오른쪽 자식 노드로 차근차근 들어가
				는 구조의 이진트리. 즉 중간에 공백 없이 빽빽히 가득
				찬 구조
 힙 : 힙은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진트리를 기반으로
 	  하는 트리. 힙에는 최대 힙과 최소 힙이 존재하는데 최대 힙은 부모 노드가
	   자식노드보다 큰 힙을 의미.
	   힙 정렬을 위해서는 정해진 데이터를 힙 구조를 가지도록 만드는 과정이
	   필요함 
	   
  힙 정렬을 사용하기 위헤서는 힙 생성 알고리즘(Heapify Algorithm)을 사용함. 힙 생성
 알고리즘은 특정한 '하나의 노드'에 대해 수행하는 것으로, 하나의 노드를 제외하고는 
 최대 힙이 구성되어 있는 상태라고 가정하고 수행됨
 특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘. 이러한 과
 정을 자식이 더 이상 존재하지 않을때까지 반복함으로써 힙의 형태를 생성 
  힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 굉장히 중요한 알고리즘
 시간복잡도는 O(log N) 
  힙 생성 -> Root값을 밑으로 보내는 과정을 반복하기 때문에 인자의 개수 N * 힙생성 알고리즘의
  시간복잡도 logN = N*logN 
  
  병합정렬과 다르게 추가적인 배열이 필요하지 않은 점에서 메모리 측면에서 효율적이라고 할 수
  있으며, 항상 NlogN의 시간복잡도를 보장한다는 점에서 몹시 강력한 알고리즘. 이론적으로는 퀵
  정렬 및 병합 정렬보다 더 우위에 있다고 할 수 있지만 단순 속도로만 비교하면 퀵정렬이 평균적
  으로 더 빠르기 때문에 많이 사용되지는 않음. 
*/

#include <stdio.h>
#include <iostream>

using namespace std;
 
int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(){
	// 먼저 전체 트리 구조를 최대 힙 구조로 바꿉니다. 
	for(int i = 1; i < number; i++){
		int c = i;
		do{
			int root = (c - 1) / 2;
			if(heap[root] < heap[c]){
				int temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp;
			}
			c = root;
		} while(c != 0);
	}

	// 크기를 줄여가며 반복적으로 힙을 구성
	for(int i = number - 1; i >= 0; i--){
		int temp = heap[0];
		heap[0] = heap[i];
		heap[i] = temp;
		int root = 0;
		int c = 1;
		do{
			c = 2 * root + 1;
			if(heap[c] < heap[c+1] && c < i - 1){
				c++;
			}
			if(heap[root] < heap[c] && c < i){
				int temp = heap[root];
				heap[root] = heap[c]; 
				heap[c] = temp;
			}
			root = c;
		}while(c < i);
	} 
	
	for(int i = 0; i < number; i++)
		cout << heap[i] << endl;
}
